<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SPIRAL IN</title>

  <style>
    :root{
      --bg:#07080a; --fg:#e9edf2;
      --muted:rgba(233,237,242,.72);
      --faint:rgba(233,237,242,.18);
      --danger:rgba(255,140,140,.95);
      --ok:rgba(120,255,180,.65);
    }

    html,body{
      height:100%; margin:0; background:var(--bg); color:var(--fg); overflow:hidden;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;
    }

    .wrap{ height:100%; display:grid; place-items:center; }

    .stage{
      position:relative;
      width:min(92vw,900px);
      aspect-ratio:16/9;
      border-radius:18px;
      overflow:hidden;
      background:
        radial-gradient(1200px 600px at 50% 40%, rgba(255,255,255,.06), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.03), transparent 35%);
      box-shadow:
        0 20px 80px rgba(0,0,0,.65),
        inset 0 0 0 1px rgba(255,255,255,.08);
    }

    video,canvas{
      position:absolute; inset:0; width:100%; height:100%;
      object-fit:cover;
      transform:scaleX(-1);
    }

    .scanlines{
      position:absolute; inset:0; pointer-events:none;
      background:repeating-linear-gradient(
        to bottom,
        rgba(0,0,0,0),
        rgba(0,0,0,0) 2px,
        rgba(0,0,0,.20) 3px);
      opacity:.55;
      mix-blend-mode:multiply;
      animation: scanMove 1.2s linear infinite;
    }
    @keyframes scanMove{
      0%   { transform: translateY(0); }
      100% { transform: translateY(3px); }
    }

    .grain{
      position:absolute; inset:-20%; pointer-events:none;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='180' height='180'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.85' numOctaves='2'/%3E%3C/filter%3E%3Crect width='180' height='180' filter='url(%23n)' opacity='.35'/%3E%3C/svg%3E");
      opacity:.22;
      mix-blend-mode:overlay;
      animation: grainDrift 4.8s linear infinite;
      transform: rotate(1deg);
    }
    @keyframes grainDrift{
      0%   { transform: translate(-2%,-1%) rotate(1deg); }
      50%  { transform: translate(1%,2%) rotate(1deg); }
      100% { transform: translate(-2%,-1%) rotate(1deg); }
    }

    .vignette{
      position:absolute; inset:0; pointer-events:none;
      background:radial-gradient(circle at 50% 45%,
        rgba(0,0,0,.05) 0%,
        rgba(0,0,0,.28) 55%,
        rgba(0,0,0,.75) 100%);
      opacity:.96;
    }

    .spiral{
      position:absolute; inset:-20%;
      pointer-events:none;
      opacity:.18;
      mix-blend-mode:screen;
      filter: blur(0.2px);
      animation: spiralTurn 18s linear infinite;
      transform-origin: 50% 50%;
      background:
        radial-gradient(circle at 50% 50%, rgba(255,255,255,.10), transparent 55%),
        conic-gradient(from 90deg,
          rgba(255,255,255,.08),
          rgba(255,255,255,0) 12%,
          rgba(255,255,255,.06) 24%,
          rgba(255,255,255,0) 36%,
          rgba(255,255,255,.05) 48%,
          rgba(255,255,255,0) 60%,
          rgba(255,255,255,.04) 72%,
          rgba(255,255,255,0) 84%,
          rgba(255,255,255,.03));
      mask-image: radial-gradient(circle at 50% 50%, rgba(0,0,0,1) 0%, rgba(0,0,0,.9) 55%, rgba(0,0,0,0) 78%);
      -webkit-mask-image: radial-gradient(circle at 50% 50%, rgba(0,0,0,1) 0%, rgba(0,0,0,.9) 55%, rgba(0,0,0,0) 78%);
    }
    @keyframes spiralTurn{
      0%   { transform: rotate(0deg) scale(1.02); }
      100% { transform: rotate(360deg) scale(1.02); }
    }

    /* Portal takeover overlay */
    .portal{
      position:absolute; inset:0;
      pointer-events:none;
      opacity:0;
      transform: scale(0.98);
      transition: opacity 180ms ease;
      z-index: 50;
    }
    .portal.on{
      opacity:1;
      animation: portalFall 1050ms cubic-bezier(.13,.84,.18,1) forwards;
    }

    .portal::before{
      content:"";
      position:absolute; inset:-25%;
      background:
        radial-gradient(circle at 50% 50%, rgba(255,255,255,.18), rgba(255,255,255,0) 36%),
        conic-gradient(from 0deg,
          rgba(255,255,255,.10),
          rgba(255,255,255,0) 10%,
          rgba(255,255,255,.08) 20%,
          rgba(255,255,255,0) 30%,
          rgba(255,255,255,.07) 40%,
          rgba(255,255,255,0) 50%,
          rgba(255,255,255,.06) 60%,
          rgba(255,255,255,0) 70%,
          rgba(255,255,255,.05) 80%,
          rgba(255,255,255,0) 90%,
          rgba(255,255,255,.04));
      mix-blend-mode: screen;
      filter: blur(0.6px);
      mask-image: radial-gradient(circle at 50% 50%, rgba(0,0,0,1) 0%, rgba(0,0,0,1) 62%, rgba(0,0,0,0) 82%);
      -webkit-mask-image: radial-gradient(circle at 50% 50%, rgba(0,0,0,1) 0%, rgba(0,0,0,1) 62%, rgba(0,0,0,0) 82%);
      animation: portalSpin 680ms linear infinite;
    }

    .portal::after{
      content:"";
      position:absolute; inset:0;
      background:
        radial-gradient(circle at 50% 50%,
          rgba(0,0,0,0) 0%,
          rgba(0,0,0,.35) 55%,
          rgba(0,0,0,.85) 100%);
      opacity: .9;
    }

    @keyframes portalSpin{
      from{ transform: rotate(0deg) scale(1.05); }
      to  { transform: rotate(360deg) scale(1.05); }
    }
    @keyframes portalFall{
      0%   { opacity:0; transform: scale(0.98) rotate(0deg); filter: blur(0px); }
      12%  { opacity:1; transform: scale(1.02) rotate(8deg); filter: blur(0.2px); }
      55%  { opacity:1; transform: scale(1.28) rotate(220deg); filter: blur(0.8px); }
      85%  { opacity:1; transform: scale(1.75) rotate(430deg); filter: blur(1.4px); }
      100% { opacity:1; transform: scale(2.15) rotate(560deg); filter: blur(2px); }
    }

    .hud{
      position:absolute; inset:0;
      display:grid;
      grid-template-rows:auto 1fr auto;
      padding:18px;
      pointer-events:none;
      z-index: 10;
    }

    .topline{
      display:flex;
      justify-content:space-between;
      text-transform:uppercase;
      font-size:12px;
      letter-spacing:.16em;
      color:var(--faint);
      user-select:none;
    }

    .centerPrompt{
      align-self:center;
      justify-self:center;
      background:rgba(0,0,0,.18);
      padding:22px 20px;
      border-radius:16px;
      text-align:center;
      max-width:620px;
      box-shadow:inset 0 0 0 1px rgba(255,255,255,.07);
      pointer-events:auto;
      backdrop-filter: blur(10px);

      /* animation hooks */
      transition: transform 520ms cubic-bezier(.14,.9,.18,1), opacity 420ms ease, filter 520ms ease;
      will-change: transform, opacity, filter;
    }

    /* NEW: when mirroring, slide prompt up off the view */
    body.mirroring .centerPrompt{
      transform: translateY(-60vh);
      opacity: 0.0;
      filter: blur(2px);
      pointer-events:none;
    }

    .title{
      margin:0 0 10px;
      font-size:clamp(18px,3vw,26px);
      letter-spacing:.18em;
      text-transform:uppercase;
    }

    .sub{
      color:rgba(233,237,242,.62);
      font-size:13px;
      margin:0 0 16px;
      line-height:1.5;
      letter-spacing:.02em;
    }

    .row{
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
      margin-top:2px;
    }

    button{
      border:0;
      border-radius:999px;
      padding:10px 14px;
      background:rgba(233,237,242,.10);
      color:#fff;
      font-size:12px;
      letter-spacing:.12em;
      text-transform:uppercase;
      cursor:pointer;
      box-shadow:inset 0 0 0 1px rgba(255,255,255,.10);
    }
    button:hover{ background:rgba(233,237,242,.14); }
    button[disabled]{ opacity:.35; cursor:not-allowed; }

    .hintline{
      margin-top:12px;
      font-size:12px;
      color:rgba(233,237,242,.55);
      letter-spacing:.04em;
      user-select:none;
    }

    .bottom{
      display:flex;
      justify-content:space-between;
      font-size:11px;
      text-transform:uppercase;
      color:var(--faint);
      user-select:none;
    }

    .statusDot{
      width:8px; height:8px; border-radius:50%;
      background:rgba(255,255,255,.2);
      display:inline-block;
      margin-right:6px;
      box-shadow:0 0 0 2px rgba(255,255,255,.06);
    }
    .statusDot.on{
      background:var(--ok);
      box-shadow:0 0 0 2px rgba(120,255,180,.12), 0 0 18px rgba(120,255,180,.18);
    }

    .error{
      margin-top:10px;
      font-size:12px;
      color:var(--danger);
      display:none;
    }

    @media(max-width:520px){
      .stage{ aspect-ratio:9/16; }
      body.mirroring .centerPrompt{ transform: translateY(-80vh); }
    }
  </style>
</head>

<body>
<div class="wrap">
  <div class="stage">
    <video id="vid" autoplay muted playsinline></video>
    <canvas id="fx"></canvas>

    <div class="spiral" aria-hidden="true"></div>
    <div class="scanlines" aria-hidden="true"></div>
    <div class="grain" aria-hidden="true"></div>
    <div class="vignette" aria-hidden="true"></div>

    <div class="portal" id="portal" aria-hidden="true"></div>

    <div class="hud">
      <div class="topline">
        <div>SPIRAL IN</div>
        <div id="clock">â€”</div>
      </div>

      <div class="centerPrompt">
        <h1 class="title">Look inward.</h1>
        <p class="sub" id="sub">The gate opens in reflection.</p>

        <div class="row">
          <button id="btnCamera">Enable Mirror</button>
          <button id="btnTry" disabled>Try Again</button>
          <button id="btnStop" disabled>Stop</button>
        </div>

        <div class="hintline" id="hint">Hold still. Become present.</div>
        <div class="error" id="err"></div>
      </div>

      <div class="bottom">
        <div>
          <span class="statusDot" id="dot"></span>
          <span id="status">Mirror idle</span>
        </div>
        <div><!-- blank --></div>
      </div>
    </div>
  </div>
</div>

<script>
  const SECRET_URL = "https://www.photonisdead.com/";

  const vid = document.getElementById("vid");
  const fx  = document.getElementById("fx");
  const ctx = fx.getContext("2d", { willReadFrequently: true });

  const btnCamera = document.getElementById("btnCamera");
  const btnTry    = document.getElementById("btnTry");
  const btnStop   = document.getElementById("btnStop");

  const statusEl = document.getElementById("status");
  const dot      = document.getElementById("dot");
  const errEl    = document.getElementById("err");

  const hint   = document.getElementById("hint");
  const sub    = document.getElementById("sub");
  const clock  = document.getElementById("clock");
  const portal = document.getElementById("portal");

  let stream = null;
  let raf = null;

  let tPortal = null;
  let tRedirect = null;
  let redirectArmed = false;

  let trackingPhase = Math.random() * 1000;
  let glitchUntil = 0;

  setInterval(() => {
    const d = new Date();
    clock.textContent =
      d.getHours().toString().padStart(2,"0") + ":" +
      d.getMinutes().toString().padStart(2,"0") + ":" +
      d.getSeconds().toString().padStart(2,"0");
  }, 300);

  function setStatus(t, on=false){
    statusEl.textContent = t;
    dot.classList.toggle("on", on);
  }

  function showError(t){
    errEl.style.display = "block";
    errEl.textContent = t;
  }

  function clearError(){
    errEl.style.display = "none";
    errEl.textContent = "";
  }

  function size(){
    const r = fx.getBoundingClientRect();
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    fx.width = Math.floor(r.width * dpr);
    fx.height = Math.floor(r.height * dpr);
  }
  window.addEventListener("resize", size);

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  function clearTimers(){
    if (tPortal) { clearTimeout(tPortal); tPortal = null; }
    if (tRedirect){ clearTimeout(tRedirect); tRedirect = null; }
    redirectArmed = false;
  }

  function beginPortalAndRedirect(){
    if (redirectArmed) return;
    redirectArmed = true;

    sub.textContent = "Recognized.";
    hint.textContent = "Falling inward.";

    // Portal starts ~1.0s after enable, redirect at ~2.0s
    tPortal = setTimeout(() => portal.classList.add("on"), 1000);
    tRedirect = setTimeout(() => { window.location.href = SECRET_URL; }, 2000);
  }

  async function startCam(){
    clearError();
    portal.classList.remove("on");
    clearTimers();

    // bring UI back if it was hidden
    document.body.classList.remove("mirroring");

    btnTry.disabled = true;
    hint.textContent = "Permission requested.";
    sub.textContent = "The gate opens in reflection.";

    try{
      stream = await navigator.mediaDevices.getUserMedia({
        video:{ facingMode:"user" },
        audio:false
      });

      vid.srcObject = stream;
      await vid.play();

      size();

      btnStop.disabled = false;
      setStatus("Mirror active", true);

      // NEW: move prompt off-screen so they can see themselves
      document.body.classList.add("mirroring");

      // As requested: portal + redirect shortly after enable
      beginPortalAndRedirect();

      loop();
    }catch(e){
      stream = null;
      btnStop.disabled = true;
      btnTry.disabled = false;

      setStatus("Mirror denied", false);
      showError("Reflection required.");
      hint.textContent = "Try again.";
      sub.textContent = "The answer is not outside.";

      document.body.classList.remove("mirroring");
    }
  }

  function stopCam(){
    if (raf) cancelAnimationFrame(raf);
    clearTimers();
    portal.classList.remove("on");

    document.body.classList.remove("mirroring");

    if (stream){
      stream.getTracks().forEach(t => t.stop());
    }
    stream = null;

    btnStop.disabled = true;
    btnTry.disabled = false;

    setStatus("Mirror stopped", false);
    showError("The loop resets.");
    hint.textContent = "Look inward.";
  }

  function draw(){
    const w = fx.width, h = fx.height;
    const now = performance.now();

    if (Math.random() < 0.02) glitchUntil = now + 240 + Math.random()*220;
    const glitching = now < glitchUntil;

    const wobble = Math.sin((now + trackingPhase) * 0.0032) * 1.8;
    const jitter = (Math.random() - 0.5) * (glitching ? 2.8 : 1.2);

    ctx.save();
    ctx.clearRect(0,0,w,h);
    ctx.translate(wobble + jitter, 0);
    ctx.drawImage(vid, 0, 0, w, h);
    ctx.restore();

    const img = ctx.getImageData(0,0,w,h);
    const d = img.data;

    const barY = (((now*0.10) + trackingPhase*33) % (h + 240)) - 120;
    const barHalf = 26;

    const headBandY = h * 0.87;
    const headBandH = Math.max(12, Math.floor(h * 0.075));
    const headShift = (Math.sin(now*0.022) * 10) + (Math.random()-0.5) * (glitching ? 14 : 7);

    for (let y=0; y<h; y++){
      const scanDarken = (y % 3 === 0) ? 0.88 : 1.00;
      const inHeadBand = (y > headBandY && y < headBandY + headBandH);
      const trackBoost = (Math.abs(y - barY) < barHalf) ? 1.16 : 1.0;

      for (let x=0; x<w; x++){
        const i = (y*w + x) * 4;

        const r = d[i], g = d[i+1], b = d[i+2];
        let yv = 0.2126*r + 0.7152*g + 0.0722*b;

        yv = (yv - 128) * 1.22 + 128;

        let rr = yv * 0.97;
        let gg = yv * 0.99;
        let bb = yv * 1.05;

        const n = (Math.random() - 0.5) * (glitching ? 18 : 12);
        rr += n; gg += n; bb += n;

        rr *= trackBoost * scanDarken;
        gg *= trackBoost * scanDarken;
        bb *= trackBoost * scanDarken;

        d[i]   = clamp(rr, 0, 255);
        d[i+1] = clamp(gg, 0, 255);
        d[i+2] = clamp(bb, 0, 255);

        if (inHeadBand && x > 3){
          const j = i - 12;
          d[i]   = (d[i]   * 0.60 + d[j]   * 0.40);
          d[i+1] = (d[i+1] * 0.60 + d[j+1] * 0.40);
          d[i+2] = (d[i+2] * 0.60 + d[j+2] * 0.40);
        }
      }
    }

    ctx.putImageData(img, 0, 0);

    if (glitching || Math.random() < 0.07){
      const gy = Math.floor(Math.random() * h);
      const gh = Math.floor(8 + Math.random() * 22);
      const shift = Math.floor((Math.random()-0.5) * (glitching ? 110 : 45));
      try{
        const band = ctx.getImageData(0, gy, w, gh);
        ctx.putImageData(band, shift, gy);
      }catch(_){}
    }

    try{
      const hb = ctx.getImageData(0, Math.floor(headBandY), w, headBandH);
      ctx.putImageData(hb, Math.floor(headShift), Math.floor(headBandY));
    }catch(_){}

    ctx.fillStyle = "rgba(0,0,0,0.10)";
    ctx.fillRect(0,0,w,h);
  }

  function loop(){
    if (!stream) return;
    draw();
    raf = requestAnimationFrame(loop);
  }

  btnCamera.onclick = startCam;
  btnTry.onclick = startCam;
  btnStop.onclick = stopCam;

  document.addEventListener("visibilitychange",()=>{
    if(document.hidden) stopCam();
  });
</script>
</body>
</html>
